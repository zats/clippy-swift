import Foundation

public enum AnimationEnumGenerator {
    public static func swiftEnumSource(
        typeName: String,
        caseValues: [String],
        accessModifier: String = "public"
    ) -> String {
        let sanitizedTypeName = sanitizeTypeName(typeName)
        let generatedCases = makeCases(values: caseValues)

        var lines: [String] = []
        lines.append("// Generated by AnimationEnumGenerator.")
        lines.append("import Foundation")
        lines.append("")
        lines.append("\(accessModifier) enum \(sanitizedTypeName): String, CaseIterable, Sendable {")
        for generatedCase in generatedCases {
            lines.append("    case \(generatedCase.identifier) = \(swiftStringLiteral(generatedCase.rawValue))")
        }
        lines.append("}")
        lines.append("")
        return lines.joined(separator: "\n")
    }
}

private struct EnumCase {
    let identifier: String
    let rawValue: String
}

private let swiftKeywords: Set<String> = [
    "associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func", "import", "init", "inout",
    "internal", "let", "open", "operator", "private", "protocol", "public", "static", "struct", "subscript",
    "typealias", "var", "break", "case", "continue", "default", "defer", "do", "else", "fallthrough", "for",
    "guard", "if", "in", "repeat", "return", "switch", "where", "while", "as", "catch", "false", "is", "nil",
    "rethrows", "super", "self", "Self", "throw", "throws", "true", "try"
]

private func makeCases(values: [String]) -> [EnumCase] {
    var seen: [String: Int] = [:]
    var result: [EnumCase] = []
    result.reserveCapacity(values.count)

    for (index, rawValue) in values.enumerated() {
        let baseIdentifier = sanitizeCaseName(rawValue, fallbackIndex: index)
        let suffix = seen[baseIdentifier, default: 0]
        seen[baseIdentifier] = suffix + 1
        let identifier = suffix == 0 ? baseIdentifier : "\(baseIdentifier)\(suffix + 1)"
        result.append(EnumCase(identifier: identifier, rawValue: rawValue))
    }

    return result
}

private func sanitizeTypeName(_ value: String) -> String {
    let parts = splitToAlnumParts(value)
    if parts.isEmpty {
        return "AnimationName"
    }

    let joined = parts
        .map { part in part.prefix(1).uppercased() + part.dropFirst() }
        .joined()

    if let first = joined.first, first.isNumber {
        return "Type\(joined)"
    }
    return joined
}

private func sanitizeCaseName(_ value: String, fallbackIndex: Int) -> String {
    let parts = splitToAlnumParts(value)
    var identifier: String
    if parts.isEmpty {
        identifier = "animation\(fallbackIndex + 1)"
    } else {
        identifier = parts[0].prefix(1).lowercased() + parts[0].dropFirst()
        if parts.count > 1 {
            for part in parts.dropFirst() {
                identifier += part.prefix(1).uppercased() + part.dropFirst()
            }
        }
    }

    if let first = identifier.first, first.isNumber {
        identifier = "n\(identifier)"
    }
    if swiftKeywords.contains(identifier) {
        identifier = "\(identifier)Value"
    }
    return identifier
}

private func splitToAlnumParts(_ value: String) -> [String] {
    var parts: [String] = []
    var current = ""
    var previous: UnicodeScalar?

    func flush() {
        if !current.isEmpty {
            parts.append(current)
            current = ""
        }
    }

    for scalar in value.unicodeScalars {
        guard CharacterSet.alphanumerics.contains(scalar) else {
            flush()
            previous = nil
            continue
        }

        if let previous,
            CharacterSet.lowercaseLetters.contains(previous),
            CharacterSet.uppercaseLetters.contains(scalar) {
            flush()
        }

        current.append(String(scalar))
        previous = scalar
    }
    flush()
    return parts
}

private func swiftStringLiteral(_ value: String) -> String {
    let escaped = value
        .replacingOccurrences(of: "\\", with: "\\\\")
        .replacingOccurrences(of: "\"", with: "\\\"")
    return "\"\(escaped)\""
}
